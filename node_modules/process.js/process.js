/*!
* process.js v0.0.1
* http://processjs.jakubkowalczyk.pl/
*
* Released under the MIT license
*
* Date: 2015-06-08
*/
(function(Q){
    /**
     * Process constructor
     * 
     * @constructor
     * @returns {Process}
     */
    var Process = function(){
        /**
         * Array of promises
         * 
         * @type {Promise[]}
         */
        this.tasks = [];
        
        /**
         * Number of threads
         * 
         * @type {Number}
         */
        this.threadsQuantity = 1;
        
        /**
         * Array of threads
         * 
         * @type {Promise[]}
         */
        this.threads = [Q.when()];
    };
    
    Process.prototype = {
        /**
         * Set number of threads
         * 
         * @param {Number} quantity
         */
        setThreadsQuantity: function(quantity){
            this.threadsQuantity = quantity;
            this.run();
        },
        
        /**
         * Add tasks
         * 
         * @param {Promise[]} promises
         */
        push: function(promises){
            this.tasks = this.tasks.concat(promises);
            this.run();
        },
        
        /**
         * Check if there are free threads and waiting tasks,
         * then start first waiting task.
         */
        run: function(){
            var self = this;
            var tasks = this.tasks;
            
            this.threads = this.threads.concat((function(){
                var threads = [];
                
                // If threads quantity parameter has been increased then add more threads
                for(var i = self.threads.length; i < self.threadsQuantity; ++i){
                    threads.push(Q.when());
                }
                
                return threads;
            })());
            this.threads.forEach(function(thread, index){
                if(!thread.isWorking){
                    if(self.threadsQuantity < self.threads.length){
                        // If threads quantity parameter has been decreased
                        // and this thread is free, then remove it
                        self.threads.splice(index,1);
                    }
                    else if(tasks.length) {
                        // If thread is free and there is waiting task, then start task
                        thread.then(tasks.shift()).then(function(){
                            thread.isWorking = false;
                            self.run();
                        });
                        thread.isWorking = true;
                    }
                }
            });
        }
    };
    
    Q.process = function(){
        return new Process();
    };
})(Q);
